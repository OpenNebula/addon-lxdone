#!/usr/bin/python

# -------------------------------------------------------------------------- #
# Copyright 2016-2017                                                        #
#                                                                            #
# Portions copyright OpenNebula Project (OpenNebula.org), CG12 Labs          #
#                                                                            #
# Licensed under the Apache License, Version 2.0 (the "License"); you may    #
# not use this file except in compliance with the License. You may obtain    #
# a copy of the License at                                                   #
#                                                                            #
# http://www.apache.org/licenses/LICENSE-2.0                                 #
#                                                                            #
# Unless required by applicable law or agreed to in writing, software        #
# distributed under the License is distributed on an "AS IS" BASIS,          #
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   #
# See the License for the specific language governing permissions and        #
# limitations under the License.                                             #
# -------------------------------------------------------------------------- #

import lxd_common as lc
import lxd_unified_image as lui
t0 = lc.time()
from lxd_common import xml_query_list as xql
from lxd_common import xml_query_item as xqi
from pylxd.exceptions import LXDAPIException
client = lc.Client()
import hashlib
import isoparser

def create_profile(xml):
    """
    create container's profile from deployment.N XML file
    """
    dicc = lc.xml_start(xml)
    profile = {'config': [], 'devices': []}

    # GENERAL_CONFIG
    profile['config'].append(lc.map_ram(xqi('MEMORY', dicc)))
    profile['config'].append(lc.map_cpu(xqi('CPU', dicc)))  # cpu percentage
    profile['config'].append(lc.map_vcpu(xqi('VCPU', dicc)))  # cpu core
    profile['config'].append({'user.hostname': dicc["/VM/NAME"][0]})
    profile['config'].append(lc.map_xml(xml))

    # LXD security.privileged
    if dicc.get('/VM/USER_TEMPLATE/LXD_CONFIG/SECURITY_PRIVILEGED'):
        profile['config'].append(
            {'security.privileged':
            dicc.get('/VM/USER_TEMPLATE/LXD_CONFIG/SECURITY_PRIVILEGED')[0]})

    # LXD security.nesting
    if dicc.get('/VM/USER_TEMPLATE/LXD_CONFIG/SECURITY_NESTING'):
        profile['config'].append(
            {'security.nesting':
            dicc.get('/VM/USER_TEMPLATE/LXD_CONFIG/SECURITY_NESTING')[0]})

    if dicc.get('/VM/TEMPLATE/DISK/LXD_QUOTA_SIZE'):
        profile['LXD_QUOTA_SIZE'] = dicc.get('/VM/TEMPLATE/DISK/LXD_QUOTA_SIZE')[0]

    # NETWORK_CONFIG
    NIC = xql('NIC/NIC_ID', dicc)
    if NIC[0]:
        NIC_BRIDGE = xql('NIC/BRIDGE', dicc)
        NIC_IP = xql('NIC/IP', dicc)
        NIC_MAC = xql('NIC/MAC', dicc)
        NIC_TARGET = xql('NIC/TARGET', dicc)
        for iface in NIC:
            i = int(iface)
            name = 'eth%s' % (iface)
            profile['devices'].append(lc.map_nic(name, NIC_BRIDGE[i], NIC_MAC[i], NIC_TARGET[i]))

    # IDs
    profile['VM_ID'] = dicc["/VM/ID"][0]
    profile['DS_ID'] = dicc["/VM/HISTORY_RECORDS/HISTORY/DS_ID"][0]
    profile['CONTEXT_DISK_ID'] = xqi('CONTEXT/DISK_ID', dicc)

    # dicc (for lc.vnc_start())
    profile['dicc'] = dicc

    return profile

def apply_profile(profile, container):
    """
    apply config and devices and quota to container
    """
    for i in profile['config']:
        try:
            container.config.update(i)
            container.save(wait=True)
            lc.log_function('INFO', 'container: ' + i.keys()[0] + ': ' + i[i.keys()[0]])
        except LXDAPIException as lxdapie:
            lc.log_function('WARN', 'container: ' + i.keys()[0] + ': ' + str(lxdapie))
            del container.config[i.keys()[0]]

    for i in profile['devices']:
        try:
            container.devices.update(i)
            container.save(wait=True)
            lc.log_function('INFO', 'container: ' + i.keys()[0] + ': added')
        except LXDAPIException as lxdapie:
            lc.log_function('WARN', 'container: ' + i.keys()[0] + ': ' + str(lxdapie))
            del container.config[i.keys()[0]]

        # disk quota
    if profile.get('LXD_QUOTA_SIZE'):
        try:
            container.devices['root']['size'] = profile['LXD_QUOTA_SIZE'] + 'MB'
            container.save(wait=True)
            lc.log_function('INFO', 'container: root disk size ' + profile['LXD_QUOTA_SIZE'] + 'MB')
        except LXDAPIException as lxdapie:
            lc.log_function('WARN','container: disk size ' + profile['LXD_QUOTA_SIZE'] + ': ' + str(lxdapie))
            del container.devices['root']['size']


# READ_XML
xml = lc.sys.argv[1]
with open(xml, 'wb') as f:
    f.write(lc.sys.stdin.read())

profile = create_profile(xml)

VM_ID = profile['VM_ID']
DS_ID = profile['DS_ID']
CONTEXT_DISK_ID = profile['CONTEXT_DISK_ID']
VM_NAME = 'one-' + VM_ID
DS_LOCATION = '/var/lib/one/datastores/' + DS_ID + '/' + VM_ID + '/'

lc.log_function('INFO', 70 * "-")

# import disk.0 to local LXD image store
with open(DS_LOCATION + 'disk.0', 'rb') as f:
    # get sha256 fingerprint of disk.0
    sha256 = hashlib.sha256()
    for chunk in iter(lambda: f.read(2048 * sha256.block_size), b''):
        sha256.update(chunk)

    fingerprint = sha256.hexdigest()
    try:
        lc.log_function('INFO', 'image: ' + fingerprint + ' importing')
        f.seek(0)
        image_data = f.read()
        image = client.images.create(image_data, wait=True)
        lc.log_function('INFO', 'image: ' + fingerprint + ' imported')
    except LXDAPIException as lxdapie:
        # probably this image already exists on local LXD image store
        lc.log_function('INFO', 'image: ' + fingerprint + ' ' + str(lxdapie))
        image = client.images.get(fingerprint)

# INITIALIZE_CONTAINER
init = {'name': VM_NAME, 'source': {'type': 'image', 'fingerprint': fingerprint}}
try:
    lc.log_function('INFO', 'container: ' + VM_NAME + ' creating')
    container = client.containers.create(init, wait=True)
except LXDAPIException as lxdapie:
    # probably this container already exists
    lc.log_function('INFO', 'container: ' + VM_NAME + ' ' + str(lxdapie))
    container = client.containers.get(VM_NAME)

# push context files into the container
contextiso = isoparser.parse(DS_LOCATION + 'disk.' + CONTEXT_DISK_ID)
for i in contextiso.record().children:
    if i.is_directory == True:
        # FIXME: implement directory copy
        continue
    container.files.put('/mnt/' + i.name, i.content)

# BOOT_CONTAINER
apply_profile(profile, container)
try:
    container.start(wait=True)
    container.config['user.xml']  # validate config
    lc.log_function('INFO', 'container: ' + VM_NAME + ' running')
except LXDAPIException as lxdapie:
    if container.status == 'Running':
        container.stop(wait=True)
    lui.uniimg_container_wipe(client, container)
    lc.log_function('ERROR', 'container: ' + str(lxdapie))
    lc.sys.exit(1)

lc.vnc_start(VM_ID, profile['dicc'])
lc.clock(t0, VM_ID)
print VM_NAME
